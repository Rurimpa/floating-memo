<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>浮遊メモ</title>
  <style>
    /* 全体レイアウト */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    header {
      background-color: #f8f8f8;
      padding: 10px;
      border-bottom: 1px solid #ddd;
      text-align: center;
    }
    header h1 {
      margin: 0 0 10px 0;
    }
    .header-buttons button {
      margin: 0 5px;
      padding: 5px 10px;
      font-size: 14px;
    }
    /* シャッフル表示ボタン：虹色グラデーション */
    #shuffle-btn {
      background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);
      color: #fff;
      border: none;
    }
    /* 画面切替用 */
    .container {
      padding: 10px;
    }
    /* タスク追加フォーム */
    #task-form {
      margin-bottom: 10px;
      text-align: center;
    }
    #task-form textarea,
    #task-form input,
    #task-form select,
    #task-form button {
      margin: 5px;
      padding: 5px;
      font-size: 14px;
    }
    /* タスクボード */
    #task-board, #completed-board {
      position: relative;
      width: 100%;
      min-height: 500px;
      border: 1px solid #ccc;
      overflow: auto;
      background-color: #eef;
    }
    /* 各付箋の基本スタイル（可変サイズ） */
    .task {
      position: absolute;
      min-width: 150px;
      min-height: 130px;
      border: 2px solid #f0c36d;
      border-radius: 5px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      background-color: #fff;
      padding: 5px;
      box-sizing: border-box;
      transition: top 0.8s ease, left 0.8s ease;
      cursor: pointer;
      overflow: hidden;
    }
    /* 重要度による背景色 */
    .importance-high { background-color: pink; }
    .importance-medium { background-color: orange; }
    .importance-low { background-color: lightyellow; }
    /* 緊急時（期限24時間以内）：枠を太くして点滅 */
    @keyframes blink {
      0%   { border-color: red; }
      50%  { border-color: darkred; }
      100% { border-color: red; }
    }
    .urgent {
      border-width: 4px !important;
      animation: blink 1s infinite;
    }
    /* 付箋内のテキスト */
    .memo-content {
      font-weight: bold;
      line-height: 1.4;
    }
    .meta-info {
      font-size: 12px;
    }
    .btn-group button {
      font-size: 12px;
      margin-right: 3px;
      padding: 2px 5px;
    }
    /* 浮遊アニメーション＋回転（シャッフル時用） */
    .float {
      animation: floatAnimation 3s ease-in-out infinite;
    }
    @keyframes floatAnimation {
      0%   { transform: rotate(var(--rotation, 0deg)) translateY(0); }
      50%  { transform: rotate(var(--rotation, 0deg)) translateY(-10px); }
      100% { transform: rotate(var(--rotation, 0deg)) translateY(0); }
    }
    /* ヘッダー内ボタン間の余白 */
    #active-header button:nth-child(3) {
      margin-right: 20px;
    }
  </style>
</head>
<body>
  <header>
    <h1>浮遊メモ</h1>
    <!-- アクティブタスク用ヘッダー -->
    <div id="active-header" class="header-buttons">
      <button onclick="sortTasks('deadline', 'active')">期限順</button>
      <button onclick="sortTasks('importance', 'active')">重要度順</button>
      <button onclick="sortTasks('created', 'active')">記入順</button>
      <button id="shuffle-btn" onclick="shuffleTasks()">シャッフル表示</button>
      <button onclick="showCompleted()" style="margin-left:20px;">完了したもの</button>
    </div>
    <!-- 完了済みタスク用ヘッダー -->
    <div id="completed-header" class="header-buttons" style="display: none;">
      <button onclick="sortTasks('deadline', 'completed')">期限順</button>
      <button onclick="sortTasks('importance', 'completed')">重要度順</button>
      <button onclick="sortTasks('created', 'completed')">記入順</button>
      <button onclick="showActive()" style="margin-left:20px;">メモ</button>
    </div>
  </header>
  <div class="container">
    <!-- アクティブタスク画面 -->
    <div id="active-view" style="display: block;">
      <form id="task-form">
        <textarea id="task-content" placeholder="タスク内容" required rows="3"></textarea><br>
        <input type="datetime-local" id="task-deadline">
        <select id="task-importance">
          <option value="1">低</option>
          <option value="2">中</option>
          <option value="3">高</option>
        </select>
        <button type="submit">メモの追加</button>
      </form>
      <div id="task-board"></div>
    </div>
    <!-- 完了済みタスク画面 -->
    <div id="completed-view" style="display: none;">
      <div id="completed-board"></div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      let activeTasks = [];
      let completedTasks = [];
      let taskId = 0;
      let highestZ = 1000; // グローバルな z-index の管理
      let autoShuffleTimeout;

      // ユーザー操作があるたびに自動シャッフルタイマーをリセットする
      function resetAutoShuffleTimer() {
        if (autoShuffleTimeout) clearTimeout(autoShuffleTimeout);
        autoShuffleTimeout = setTimeout(function() {
          if (document.getElementById('active-view').style.display !== 'none') {
            shuffleTasks();
          }
        }, 30000);
      }
      // 入力、スクロール、タップ、ドラッグなどの操作でタイマーをリセット
      ['mousemove', 'touchstart', 'scroll', 'keydown', 'click'].forEach(function(eventName) {
        document.addEventListener(eventName, resetAutoShuffleTimer);
      });
      resetAutoShuffleTimer();

      function saveTasks() {
        localStorage.setItem('activeTasks', JSON.stringify(activeTasks));
        localStorage.setItem('completedTasks', JSON.stringify(completedTasks));
        localStorage.setItem('taskId', taskId.toString());
      }
      function loadTasks() {
        try {
          const storedActive = localStorage.getItem('activeTasks');
          const storedCompleted = localStorage.getItem('completedTasks');
          const storedId = localStorage.getItem('taskId');
          activeTasks = storedActive ? JSON.parse(storedActive) : [];
          completedTasks = storedCompleted ? JSON.parse(storedCompleted) : [];
          taskId = storedId ? parseInt(storedId, 10) : 0;
        } catch (e) {
          console.error("localStorage読み込みエラー", e);
          activeTasks = [];
          completedTasks = [];
          taskId = 0;
        }
      }

      function formatDate(dateStr) {
        const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
        return new Date(dateStr).toLocaleString('ja-JP', options);
      }

      function getImportanceStars(imp) {
        if (imp === 3) return "★★★";
        if (imp === 2) return "★★";
        return "★";
      }

      // アクティブタスクのレンダリング（グリッドレイアウト、サイズは内容に合わせて可変）
      function renderActiveTasks() {
        const board = document.getElementById('task-board');
        board.innerHTML = '';
        activeTasks.forEach((task, index) => {
          const taskDiv = createTaskDiv(task, false);
          const cols = Math.floor(board.clientWidth / 170) || 1;
          const row = Math.floor(index / cols);
          const col = index % cols;
          taskDiv.style.top = (row * 170 + 10) + 'px';
          taskDiv.style.left = (col * 170 + 10) + 'px';
          taskDiv.classList.remove('float');
          taskDiv.style.transform = 'none';
          board.appendChild(taskDiv);
        });
      }

      function renderCompletedTasks() {
        const board = document.getElementById('completed-board');
        board.innerHTML = '';
        completedTasks.forEach((task, index) => {
          const taskDiv = createTaskDiv(task, true);
          const cols = Math.floor(board.clientWidth / 170) || 1;
          const row = Math.floor(index / cols);
          const col = index % cols;
          taskDiv.style.top = (row * 170 + 10) + 'px';
          taskDiv.style.left = (col * 170 + 10) + 'px';
          board.appendChild(taskDiv);
        });
      }

      // 付箋要素作成
      function createTaskDiv(task, isCompleted) {
        const taskDiv = document.createElement('div');
        taskDiv.classList.add('task');
        // 重要度に応じたテキストサイズ
        let textSize;
        if (task.importance === 3) {
          textSize = "20px";
        } else if (task.importance === 2) {
          textSize = "18px";
        } else {
          textSize = "16px";
        }
        if (task.importance === 3) {
          taskDiv.classList.add('importance-high');
        } else if (task.importance === 2) {
          taskDiv.classList.add('importance-medium');
        } else {
          taskDiv.classList.add('importance-low');
        }
        taskDiv.dataset.id = task.id;
        if (task.deadline) {
          const deadlineTime = new Date(task.deadline).getTime();
          const now = Date.now();
          if (deadlineTime - now < 24 * 60 * 60 * 1000) {
            taskDiv.classList.add('urgent');
          }
        }
        taskDiv.innerHTML = `
          <div class="memo-content" style="font-size: ${textSize};">
            ${task.content}
          </div>
          <div class="meta-info">
            <div class="deadline">${task.deadline ? "期限: " + formatDate(task.deadline) : "期限: なし"}</div>
            <div class="importance">重要度: ${getImportanceStars(task.importance)}</div>
            <div class="created">記入日: ${formatDate(task.created)}</div>
          </div>
          <div class="btn-group">
            <button class="edit-btn" onclick="editTask(${task.id}, event)">編集</button>
            ${isCompleted ? "" : `<button class="complete-btn" onclick="completeTask(${task.id}, event)">完了</button>`}
          </div>
        `;
        // タップ時にも最前面に移動
        taskDiv.addEventListener('click', function(e) {
          if (e.target.tagName.toLowerCase() !== 'button') {
            taskDiv.style.zIndex = highestZ++;
          }
        });
        return taskDiv;
      }

      // ドラッグ可能にする関数（開始時に該当要素を最前面に）
      function enableDrag(el) {
        el.style.cursor = "move";
        el.addEventListener("mousedown", onStart);
        el.addEventListener("touchstart", onStart);
        let offsetX, offsetY;
        let dragging = false;
        function onStart(e) {
          e.preventDefault();
          // bring to front
          el.style.zIndex = highestZ++;
          dragging = true;
          if (e.type === "mousedown") {
            offsetX = e.clientX - el.offsetLeft;
            offsetY = e.clientY - el.offsetTop;
            document.addEventListener("mousemove", onMove);
            document.addEventListener("mouseup", onEnd);
          } else if (e.type === "touchstart") {
            const touch = e.touches[0];
            offsetX = touch.clientX - el.offsetLeft;
            offsetY = touch.clientY - el.offsetTop;
            document.addEventListener("touchmove", onMove);
            document.addEventListener("touchend", onEnd);
          }
        }
        function onMove(e) {
          if (!dragging) return;
          let clientX, clientY;
          if (e.type === "mousemove") {
            clientX = e.clientX;
            clientY = e.clientY;
          } else if (e.type === "touchmove") {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
          }
          el.style.left = (clientX - offsetX) + "px";
          el.style.top = (clientY - offsetY) + "px";
        }
        function onEnd(e) {
          dragging = false;
          document.removeEventListener("mousemove", onMove);
          document.removeEventListener("mouseup", onEnd);
          document.removeEventListener("touchmove", onMove);
          document.removeEventListener("touchend", onEnd);
        }
      }

      window.editTask = function(id, e) {
        e.stopPropagation();
        let task = activeTasks.find(t => t.id == id);
        if (!task) return;
        const newContent = prompt("メモ内容を編集してください：", task.content);
        if (newContent === null) return;
        const newDeadline = prompt("期限を編集してください（YYYY-MM-DDTHH:MM形式、空欄で期限なし）：", task.deadline ? task.deadline.slice(0,16) : "");
        if (newDeadline === null) return;
        const newImportance = prompt("重要度を編集してください（1:低, 2:中, 3:高）：", task.importance);
        if (newImportance === null) return;
        task.content = newContent;
        task.deadline = newDeadline ? new Date(newDeadline).toISOString() : null;
        task.importance = parseInt(newImportance) || task.importance;
        saveTasks();
        renderActiveTasks();
      };

      window.completeTask = function(id, e) {
        e.stopPropagation();
        const index = activeTasks.findIndex(t => t.id == id);
        if (index > -1) {
          const completed = activeTasks.splice(index, 1)[0];
          completedTasks.push(completed);
          saveTasks();
          renderActiveTasks();
          renderCompletedTasks();
        }
      };

      window.showCompleted = function() {
        document.getElementById('active-view').style.display = 'none';
        document.getElementById('active-header').style.display = 'none';
        document.getElementById('completed-view').style.display = 'block';
        document.getElementById('completed-header').style.display = 'block';
      };

      window.showActive = function() {
        document.getElementById('completed-view').style.display = 'none';
        document.getElementById('completed-header').style.display = 'none';
        document.getElementById('active-view').style.display = 'block';
        document.getElementById('active-header').style.display = 'block';
        renderActiveTasks();
      };

      document.getElementById('task-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const content = document.getElementById('task-content').value;
        const deadlineVal = document.getElementById('task-deadline').value;
        const importance = parseInt(document.getElementById('task-importance').value);
        const newTask = {
          id: taskId++,
          content: content,
          created: new Date().toISOString(),
          deadline: deadlineVal ? new Date(deadlineVal).toISOString() : null,
          importance: importance
        };
        activeTasks.push(newTask);
        saveTasks();
        renderActiveTasks();
        e.target.reset();
      });

      window.sortTasks = function(criteria, view) {
        const list = view === 'active' ? activeTasks : completedTasks;
        if (criteria === 'deadline') {
          list.sort((a, b) => {
            if (a.deadline && b.deadline) {
              return new Date(a.deadline) - new Date(b.deadline);
            } else if (a.deadline) {
              return -1;
            } else if (b.deadline) {
              return 1;
            }
            return 0;
          });
        } else if (criteria === 'importance') {
          list.sort((a, b) => b.importance - a.importance);
        } else if (criteria === 'created') {
          list.sort((a, b) => new Date(a.created) - new Date(b.created));
        }
        saveTasks();
        if (view === 'active') {
          renderActiveTasks();
        } else {
          renderCompletedTasks();
        }
      };

      window.shuffleTasks = function() {
        const board = document.getElementById('task-board');
        const taskDivs = board.getElementsByClassName('task');
        for (let i = 0; i < taskDivs.length; i++) {
          const taskDiv = taskDivs[i];
          const task = activeTasks.find(t => t.id == taskDiv.dataset.id);
          if (task) {
            // シャッフル時は重要度による最小サイズ設定
            if (task.importance === 3) {
              taskDiv.style.minWidth = '220px';
              taskDiv.style.minHeight = '200px';
            } else if (task.importance === 2) {
              taskDiv.style.minWidth = '180px';
              taskDiv.style.minHeight = '170px';
            } else {
              taskDiv.style.minWidth = '150px';
              taskDiv.style.minHeight = '130px';
            }
          }
          const boardWidth = board.clientWidth - taskDiv.offsetWidth;
          const boardHeight = board.clientHeight - taskDiv.offsetHeight;
          const randomLeft = Math.random() * boardWidth;
          const randomTop = Math.random() * boardHeight;
          taskDiv.style.left = randomLeft + 'px';
          taskDiv.style.top = randomTop + 'px';
          const randomAngle = Math.random() * 20 - 10;
          taskDiv.style.setProperty('--rotation', randomAngle + 'deg');
          taskDiv.classList.add('float');
          enableDrag(taskDiv);
        }
      };

      loadTasks();
      renderActiveTasks();
      renderCompletedTasks();
    });
  </script>
</body>
</html>
