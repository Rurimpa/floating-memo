<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <!-- スマホ向けに画面幅を指定、ズーム防止 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <title>浮遊メモ</title>
  <style>
    /* 全体レイアウト */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    header {
      background-color: #f8f8f8;
      padding: 10px;
      border-bottom: 1px solid #ddd;
      text-align: center;
    }
    header h1 {
      margin: 0 0 10px 0;
    }
    .header-buttons button {
      margin: 0 5px;
      padding: 5px 10px;
      font-size: 14px;
    }
    /* シャッフル表示ボタン：虹色グラデーション */
    #shuffle-btn {
      background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);
      color: #fff;
      border: none;
    }
    /* コンテナ */
    .container {
      padding: 10px;
    }
    /* タスク追加フォーム */
    #task-form {
      margin-bottom: 10px;
      text-align: center;
    }
    #task-form label {
      font-size: 14px;
    }
    #task-form textarea,
    #task-form input,
    #task-form select,
    #task-form button {
      margin: 5px;
      padding: 5px;
      font-size: 14px;
    }
    /* 期限入力は分の初期値を00にするため、後で JS で値をセット */
    /* タスクボード */
    #task-board, #completed-board {
      position: relative;
      width: 100%;
      min-height: 500px;
      border: 1px solid #ccc;
      overflow: auto;
      background-color: #eef;
    }
    /* 各付箋の基本スタイル（可変サイズ） */
    .task {
      position: absolute;
      min-width: 120px;
      min-height: 100px;
      border: 2px solid #f0c36d;
      border-radius: 5px;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      background-color: #fff;
      padding: 5px;
      box-sizing: border-box;
      transition: top 0.8s ease, left 0.8s ease;
      cursor: pointer;
      overflow: hidden;
    }
    /* 重要度による背景色 */
    .importance-high { background-color: pink; }
    .importance-medium { background-color: orange; }
    .importance-low { background-color: lightyellow; }
    /* 緊急時（期限24時間以内）：枠を太く＆点滅 */
    @keyframes blink {
      0% { border-color: red; }
      50% { border-color: darkred; }
      100% { border-color: red; }
    }
    .urgent {
      border-width: 4px !important;
      animation: blink 1s infinite;
    }
    /* 付箋内のテキスト */
    .memo-content {
      font-weight: bold;
      line-height: 1.4;
    }
    .meta-info {
      font-size: 12px;
    }
    .btn-group button {
      font-size: 12px;
      margin-right: 3px;
      padding: 2px 5px;
    }
    /* メディアクエリ：スマホの場合、上部のヘッダーとタスクフォームを隠す＆全体サイズを縮小 */
    @media screen and (max-width: 600px) {
      header, #task-form {
        display: none;
      }
      body {
        font-size: 12px;
      }
      .header-buttons button {
        font-size: 12px;
      }
      #task-board, #completed-board {
        min-height: 400px;
      }
      /* 付箋の最小サイズをさらに小さく */
      .task {
        min-width: 100px;
        min-height: 80px;
      }
    }
  </style>
</head>
<body>
  <!-- ヘッダーとタスク追加フォームはPC用。スマホではメディアクエリで非表示 -->
  <header>
    <h1>浮遊メモ</h1>
    <div id="active-header" class="header-buttons">
      <button onclick="sortTasks('deadline', 'active')">期限順</button>
      <button onclick="sortTasks('importance', 'active')">重要度順</button>
      <button onclick="sortTasks('created', 'active')">記入順</button>
      <button id="shuffle-btn" onclick="enterShuffleMode()">シャッフル表示</button>
      <button onclick="showCompleted()" style="margin-left:20px;">完了したもの</button>
    </div>
    <div id="completed-header" class="header-buttons" style="display: none;">
      <button onclick="sortTasks('deadline', 'completed')">期限順</button>
      <button onclick="sortTasks('importance', 'completed')">重要度順</button>
      <button onclick="sortTasks('created', 'completed')">記入順</button>
      <button onclick="showActive()" style="margin-left:20px;">メモ</button>
    </div>
  </header>
  <div class="container">
    <div id="active-view" style="display: block;">
      <form id="task-form">
        <textarea id="task-content" placeholder="タスク内容" required rows="3"></textarea><br>
        <label for="task-deadline">期限 (YYYY-MM-DDTHH:MM):</label>
        <input type="datetime-local" id="task-deadline">
        <select id="task-importance">
          <option value="1">低</option>
          <option value="2">中</option>
          <option value="3">高</option>
        </select>
        <button type="submit">メモの追加</button>
      </form>
      <div id="task-board"></div>
    </div>
    <div id="completed-view" style="display: none;">
      <div id="completed-board"></div>
    </div>
  </div>
  <script>
    // グローバル変数
    let activeTasks = [];
    let completedTasks = [];
    let taskId = 0;
    let highestZ = 1000;
    let shuffleMode = false;
    let shuffleAnimationId = null;
    let autoShuffleTimeout;

    // 自動シャッフルタイマーのリセット（最後の操作から30秒後にシャッフル）
    function resetAutoShuffleTimer() {
      if (autoShuffleTimeout) clearTimeout(autoShuffleTimeout);
      autoShuffleTimeout = setTimeout(() => {
        // もしアクティブビューが表示中ならシャッフルモードに移行
        if (document.getElementById('active-view').style.display !== 'none') {
          enterShuffleMode();
        }
      }, 30000);
    }
    ['mousemove', 'touchstart', 'scroll', 'keydown', 'click'].forEach(eventName => {
      document.addEventListener(eventName, resetAutoShuffleTimer);
    });
    resetAutoShuffleTimer();

    // ページ読み込み時に、期限入力の初期値を現在の日付で分は"00"にする
    window.addEventListener('DOMContentLoaded', () => {
      const deadlineInput = document.getElementById('task-deadline');
      if (deadlineInput) {
        let now = new Date();
        now.setMinutes(0, 0, 0);
        // Format date as YYYY-MM-DDTHH:MM
        const pad = n => n.toString().padStart(2, '0');
        const formatted = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}T${pad(now.getHours())}:00`;
        deadlineInput.value = formatted;
      }
    });

    // 保存・復元
    function saveTasks() {
      localStorage.setItem('activeTasks', JSON.stringify(activeTasks));
      localStorage.setItem('completedTasks', JSON.stringify(completedTasks));
      localStorage.setItem('taskId', taskId.toString());
    }
    function loadTasks() {
      try {
        const storedActive = localStorage.getItem('activeTasks');
        const storedCompleted = localStorage.getItem('completedTasks');
        const storedId = localStorage.getItem('taskId');
        activeTasks = storedActive ? JSON.parse(storedActive) : [];
        completedTasks = storedCompleted ? JSON.parse(storedCompleted) : [];
        taskId = storedId ? parseInt(storedId, 10) : 0;
      } catch (e) {
        console.error("localStorage読み込みエラー", e);
        activeTasks = [];
        completedTasks = [];
        taskId = 0;
      }
    }

    // 日付フォーマット
    function formatDate(dateStr) {
      const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' };
      return new Date(dateStr).toLocaleString('ja-JP', options);
    }

    function getImportanceStars(imp) {
      if (imp === 3) return "★★★";
      if (imp === 2) return "★★";
      return "★";
    }

    // アクティブタスクのレンダリング（グリッド配置、サイズは内容に合わせ可変）
    function renderActiveTasks() {
      const board = document.getElementById('task-board');
      board.innerHTML = '';
      activeTasks.forEach((task, index) => {
        const taskDiv = createTaskDiv(task, false);
        const cols = Math.floor(board.clientWidth / 170) || 1;
        const row = Math.floor(index / cols);
        const col = index % cols;
        taskDiv.style.top = (row * 170 + 10) + 'px';
        taskDiv.style.left = (col * 170 + 10) + 'px';
        taskDiv.classList.remove('float');
        taskDiv.style.transform = 'none';
        board.appendChild(taskDiv);
      });
    }

    function renderCompletedTasks() {
      const board = document.getElementById('completed-board');
      board.innerHTML = '';
      completedTasks.forEach((task, index) => {
        const taskDiv = createTaskDiv(task, true);
        const cols = Math.floor(board.clientWidth / 170) || 1;
        const row = Math.floor(index / cols);
        const col = index % cols;
        taskDiv.style.top = (row * 170 + 10) + 'px';
        taskDiv.style.left = (col * 170 + 10) + 'px';
        board.appendChild(taskDiv);
      });
    }

    // 付箋要素作成。重要度に応じたテキストサイズ（高:20px, 中:18px, 低:16px）
    function createTaskDiv(task, isCompleted) {
      const taskDiv = document.createElement('div');
      taskDiv.classList.add('task');
      let textSize = task.importance === 3 ? "20px" : (task.importance === 2 ? "18px" : "16px");
      if (task.importance === 3) {
        taskDiv.classList.add('importance-high');
      } else if (task.importance === 2) {
        taskDiv.classList.add('importance-medium');
      } else {
        taskDiv.classList.add('importance-low');
      }
      taskDiv.dataset.id = task.id;
      if (task.deadline) {
        const deadlineTime = new Date(task.deadline).getTime();
        if (deadlineTime - Date.now() < 24 * 60 * 60 * 1000) {
          taskDiv.classList.add('urgent');
        }
      }
      taskDiv.innerHTML = `
        <div class="memo-content" style="font-size: ${textSize};">
          ${task.content}
        </div>
        <div class="meta-info">
          <div class="deadline">${task.deadline ? "期限: " + formatDate(task.deadline) : "期限: なし"}</div>
          <div class="importance">重要度: ${getImportanceStars(task.importance)}</div>
          <div class="created">記入日: ${formatDate(task.created)}</div>
        </div>
        <div class="btn-group">
          <button class="edit-btn" onclick="editTask(${task.id}, event)">編集</button>
          ${isCompleted ? "" : `<button class="complete-btn" onclick="completeTask(${task.id}, event)">完了</button>`}
        </div>
      `;
      // タップ時にも最前面に
      taskDiv.addEventListener('click', function(e) {
        if (e.target.tagName.toLowerCase() !== 'button') {
          taskDiv.style.zIndex = highestZ++;
        }
      });
      return taskDiv;
    }

    // ドラッグ可能にする関数（開始時に最前面に移動）
    function enableDrag(el) {
      el.style.cursor = "move";
      el.addEventListener("mousedown", onStart);
      el.addEventListener("touchstart", onStart);
      let offsetX, offsetY;
      let dragging = false;
      function onStart(e) {
        e.preventDefault();
        el.style.zIndex = highestZ++;
        dragging = true;
        if (e.type === "mousedown") {
          offsetX = e.clientX - el.offsetLeft;
          offsetY = e.clientY - el.offsetTop;
          document.addEventListener("mousemove", onMove);
          document.addEventListener("mouseup", onEnd);
        } else if (e.type === "touchstart") {
          const touch = e.touches[0];
          offsetX = touch.clientX - el.offsetLeft;
          offsetY = touch.clientY - el.offsetTop;
          document.addEventListener("touchmove", onMove);
          document.addEventListener("touchend", onEnd);
        }
      }
      function onMove(e) {
        if (!dragging) return;
        let clientX, clientY;
        if (e.type === "mousemove") {
          clientX = e.clientX;
          clientY = e.clientY;
        } else if (e.type === "touchmove") {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        }
        el.style.left = (clientX - offsetX) + "px";
        el.style.top = (clientY - offsetY) + "px";
      }
      function onEnd(e) {
        dragging = false;
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onEnd);
        document.removeEventListener("touchmove", onMove);
        document.removeEventListener("touchend", onEnd);
      }
    }

    // 連続的なシャッフルモーション：各付箋は自分の速度・方向で移動し、境界でバウンス
    function animateShuffle() {
      if (!shuffleMode) return;
      const board = document.getElementById('task-board');
      const taskDivs = board.getElementsByClassName('task');
      for (let i = 0; i < taskDivs.length; i++) {
        const taskDiv = taskDivs[i];
        if (!taskDiv.velX || !taskDiv.velY) {
          const speed = Math.random() * 0.3 + 0.2; // 0.2～0.5 px/frame
          const angle = Math.random() * 2 * Math.PI;
          taskDiv.velX = Math.cos(angle) * speed;
          taskDiv.velY = Math.sin(angle) * speed;
        }
        let left = parseFloat(taskDiv.style.left);
        let top = parseFloat(taskDiv.style.top);
        left += taskDiv.velX;
        top += taskDiv.velY;
        const boardWidth = board.clientWidth;
        const boardHeight = board.clientHeight;
        const noteWidth = taskDiv.offsetWidth;
        const noteHeight = taskDiv.offsetHeight;
        if (left < 0 || left + noteWidth > boardWidth) {
          taskDiv.velX = -taskDiv.velX;
          left = Math.max(0, Math.min(left, boardWidth - noteWidth));
        }
        if (top < 0 || top + noteHeight > boardHeight) {
          taskDiv.velY = -taskDiv.velY;
          top = Math.max(0, Math.min(top, boardHeight - noteHeight));
        }
        taskDiv.style.left = left + "px";
        taskDiv.style.top = top + "px";
      }
      shuffleAnimationId = requestAnimationFrame(animateShuffle);
    }

    // シャッフルモードに入る：各付箋にランダムな位置と速度をセットして連続移動開始
    function enterShuffleMode() {
      shuffleMode = true;
      const board = document.getElementById('task-board');
      const taskDivs = board.getElementsByClassName('task');
      for (let i = 0; i < taskDivs.length; i++) {
        const taskDiv = taskDivs[i];
        taskDiv.velX = Math.random() * 0.3 + 0.2;
        taskDiv.velY = Math.random() * 0.3 + 0.2;
        const boardWidth = board.clientWidth - taskDiv.offsetWidth;
        const boardHeight = board.clientHeight - taskDiv.offsetHeight;
        taskDiv.style.left = (Math.random() * boardWidth) + "px";
        taskDiv.style.top = (Math.random() * boardHeight) + "px";
        taskDiv.style.zIndex = highestZ++;
        enableDrag(taskDiv);
      }
      animateShuffle();
    }

    // シャッフルモード終了：連続移動を停止し、グリッドレイアウトに再配置
    function exitShuffleMode() {
      shuffleMode = false;
      if (shuffleAnimationId) {
        cancelAnimationFrame(shuffleAnimationId);
        shuffleAnimationId = null;
      }
      renderActiveTasks();
    }

    // スマホのシェイク検出：一定加速度以上なら再シャッフル
    let shakeThreshold = 15;
    let lastShakeTime = 0;
    window.addEventListener('devicemotion', function(event) {
      let acc = event.accelerationIncludingGravity;
      let magnitude = Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z);
      if (magnitude > shakeThreshold) {
        let now = Date.now();
        if (now - lastShakeTime > 1000) {
          lastShakeTime = now;
          enterShuffleMode();
        }
      }
    });

    // 編集・完了・ソート・画面切替
    window.editTask = function(id, e) {
      e.stopPropagation();
      let task = activeTasks.find(t => t.id == id);
      if (!task) return;
      const newContent = prompt("メモ内容を編集してください：", task.content);
      if (newContent === null) return;
      const newDeadline = prompt("期限を編集してください（YYYY-MM-DDTHH:MM形式、空欄で期限なし）：", task.deadline ? task.deadline.slice(0,16) : "");
      if (newDeadline === null) return;
      const newImportance = prompt("重要度を編集してください（1:低, 2:中, 3:高）：", task.importance);
      if (newImportance === null) return;
      task.content = newContent;
      task.deadline = newDeadline ? new Date(newDeadline).toISOString() : null;
      task.importance = parseInt(newImportance) || task.importance;
      saveTasks();
      renderActiveTasks();
    };

    window.completeTask = function(id, e) {
      e.stopPropagation();
      const index = activeTasks.findIndex(t => t.id == id);
      if (index > -1) {
        const completed = activeTasks.splice(index, 1)[0];
        completedTasks.push(completed);
        saveTasks();
        renderActiveTasks();
        renderCompletedTasks();
      }
    };

    window.showCompleted = function() {
      exitShuffleMode();
      document.getElementById('active-view').style.display = 'none';
      document.getElementById('active-header').style.display = 'none';
      document.getElementById('completed-view').style.display = 'block';
      document.getElementById('completed-header').style.display = 'block';
    };

    window.showActive = function() {
      document.getElementById('completed-view').style.display = 'none';
      document.getElementById('completed-header').style.display = 'none';
      document.getElementById('active-view').style.display = 'block';
      document.getElementById('active-header').style.display = 'block';
      exitShuffleMode();
      renderActiveTasks();
    };

    window.sortTasks = function(criteria, view) {
      const list = view === 'active' ? activeTasks : completedTasks;
      if (criteria === 'deadline') {
        list.sort((a, b) => {
          if (a.deadline && b.deadline) {
            return new Date(a.deadline) - new Date(b.deadline);
          } else if (a.deadline) {
            return -1;
          } else if (b.deadline) {
            return 1;
          }
          return 0;
        });
      } else if (criteria === 'importance') {
        list.sort((a, b) => b.importance - a.importance);
      } else if (criteria === 'created') {
        list.sort((a, b) => new Date(a.created) - new Date(b.created));
      }
      saveTasks();
      if (view === 'active') {
        exitShuffleMode();
        renderActiveTasks();
      } else {
        renderCompletedTasks();
      }
    };

    document.getElementById('task-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const content = document.getElementById('task-content').value;
      const deadlineVal = document.getElementById('task-deadline').value;
      const importance = parseInt(document.getElementById('task-importance').value);
      const newTask = {
        id: taskId++,
        content: content,
        created: new Date().toISOString(),
        deadline: deadlineVal ? new Date(deadlineVal).toISOString() : null,
        importance: importance
      };
      activeTasks.push(newTask);
      saveTasks();
      renderActiveTasks();
      e.target.reset();
    });

    loadTasks();
    renderActiveTasks();
    renderCompletedTasks();
  </script>
</body>
</html>
